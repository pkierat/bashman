#!/usr/bin/env bash

set -o emacs

BASHMAN_HOME="$(cd $(dirname $(realpath $0)) && pwd)"
BASHMAN_HISTORY="${HOME}/.bashman_history"
BASHMAN_PATH=${BASHMAN_PATH:-.}
BASHMAN_EDITOR=${BASHMAN_EDITOR:-${SELECTED_EDITOR:-${EDITOR:-vim}}}

_help_() {
    cat <<-END_OF_HELP
	bashman - command-line interpreter of Postman collections
	
	Available commands:
	
	    help                   Shows help.
	    col [collection]       Loads a given Postman collection file
	                           or reloads the current one.
	    env [environment]      Loads a given Postman environment file
	                           or reloads the current one.
	    item [item]	           Selects the item or reloads the current one.
	    run [item] [args]      Makes a call based on the current state.
	    exit/quit/CTRL+D       Exits Bashman.
	
	Environment variables:
	    
	    BASHMAN_HOME           Directory containing all Bashman scripts
	    BASHMAN_PATH           Comma-separated list of directories to
	                           search for collections and environments
	    BASHMAN_HISTORY	       Path to a file containing history of commands
	                           (default: \${BASHMAN_HOME}/.bashman_history)
	    
	END_OF_HELP
}

_load_() {
    local type=${1}   # environment or collection
    local -n var=${2}
    shift 2

    local -A opts
    while [[ ${1} = -* ]]; do
        case "${1}" in
            -e|--edit)  opts[edit]=1; shift ;;
            -w|--write) opts[write]=1; shift ;;
        esac
    done

    local file="${1:-${var}}"

    [[ -z "${file}" ]] && { echo "No ${type} selected." >&2; return 2; }
    [[ -f "${file}" && -r "${file}" ]] || { echo "File not found or not readable." >&2; return 1; }

    temp=$(mktemp)
    if [[ ${file} = *.json ]]; then
        jq -L "${BASHMAN_HOME}" -r -f "${BASHMAN_HOME}/${type}.jq" < "${file}" > "${temp}"
    else
        cat < "${file}" > "${temp}"
    fi

    if [[ ${opts[edit]} ]]; then
        ${BASHMAN_EDITOR} "${temp}"
    fi

    source "${temp}"
   
    if [[ ${opts[write]} ]]; then
        file="${file%.json}.sh"
        cat "${temp}" > "${file}"
    fi
 
    var="${file}"
}

_col_() {
    _load_ collection BM_COLLECTION "${@}"
}

_env_() {
    _load_ environment BM_ENV "${@}" 
    
    [[ -n "${BM_COLLECTION}" ]] && _col_ "${BM_COLLECTION}"
    [[ -n "${BM_ITEM}" ]] && _item_ "${BM_ITEM}"
}

_item_() {
    local item=${1:-${BM_ITEM}}
    [[ -z "${item}" ]] && { echo "No item selected." >&2; return 2; }

    declare -F | grep -q "${item}" || { echo "Item not found." >&2; return 1; }
    
    unset BM_NAME BM_METHOD BM_HEADER BM_BODY BM_URL
    unset BM_RESPONSE_BODY BM_RESPONSE_META BM_RESPONSE_CODE

    ${item} && BM_ITEM="${item}"
}

_run_() {
    if declare -F | grep -q "${1}"; then
        _item_ "${1}"
        shift
    fi 

    local auth headers response
    case "${BM_AUTH_TYPE}" in
        basic)
            auth="--basic -u ${BM_AUTH_USER}:${BM_AUTH_PASS}"
            ;;
        digest)
            auth="--digest -u ${BM_AUTH_USER}:${BM_AUTH_PASS}"
            ;;
        bearer)
            auth="--oauth2-bearer ${BM_AUTH_PASS} -u ${BM_AUTH_USER}"
    esac

    headers=""
    for header in "${!BM_HEADER[@]}"; do headers+=" --header '${header}: ${BM_HEADER[${header}]}'"; done

    response=$(curl \
        --silent \
        --write-out '\n%{json}' \
        --location \
        --request "${BM_METHOD}" "${BM_URL}" \
        ${auth:-} \
        ${auth## } \
        "${@}")

    BM_RESPONSE_META=$(tail -n 1 <<< "${response}")
    BM_RESPONSE_BODY=$(head -n -1 <<< "${response}")
    BM_RESPONSE_CODE=$(jq .http_code <<< "${BM_RESPONSE_META}")

    cat <<< "${BM_RESPONSE_BODY}"
}

_comp_cmd_() {
    sed -e 's/ /\n/g' <<< "col env help item run" | fzf -e -1 -0 -q "${1}"
}

_comp_load_() {
    local type="${1}"; shift
    cat \
        <(sed -e 's/ /\n/g' <<< "-e --edit -w --write") \
        <(find ${BASHMAN_PATH//:/ } -name "*.postman_${type}.*" | sed -e "s#^${PWD}##") \
        | fzf --tac +s -1 -0 -q "${1}"
}

_comp_col_() {
    _comp_load_ collection "${@}"
}

_comp_env_() {
    _comp_load_ environment "${@}"
}

_comp_item_() {
    declare -F | awk '{print $3}' | grep -v '^_' | fzf -1 -0 -q "${1}"
}

_comp_run_() {
    declare -F | awk '{print $3}' | grep -v '^_' | fzf -1 -0 -q "${1}"
}

_complete_() {
    local line="${READLINE_LINE## }"
    local cmd="${line%% *}"
    local args="${line#* }"
    
    if [[ ${#line} -le ${#cmd} ]]; then
        local comp="$(_comp_cmd_ ${cmd})"
        if [[ -n ${comp} ]]; then
            READLINE_LINE="${comp} "
            READLINE_POINT=${#READLINE_LINE}
        fi
    else
        case "${cmd}" in
            col|env|item|run)
                READLINE_LINE="${line% *} $(_comp_${cmd}_ "${args##* }") "
                READLINE_POINT=${#READLINE_LINE}
                ;;
            run|help)
                ;;
        esac
    fi
}

_prompt_() {
    echo "${BM_ENV_NAME:-[env]}:${BM_COLLECTION_NAME:-[col]}:${BM_ITEM:-[item]}:${BM_RESPONSE_CODE:-[code]}> "
}

_init_() {
    [[ -r ${HOME}/.config/bashman/config ]] && source ${HOME}/.config/bashman/config
    [[ -r ./.bashman_config ]] && source ./.bashman_config
    [[ -n "${BM_ENV}" && -r "${BM_ENV}" ]] && _env_ "${BM_ENV}"
    [[ -n "${BM_COLLECTION}" && -r "${BM_COLLECTION}" ]] && _col_ "${BM_COLLECTION}"
    [[ -n "${BM_ITEM}" && -r "${BM_ITEM}" ]] && _item_ "${BM_ITEM}"
}

_init_
_help_

touch "${BASHMAN_HISTORY}"
history -r "${BASHMAN_HISTORY}"

bind -x '"\t":"_complete_"'

while read -e -p "$(_prompt_)" -a CMDLINE; do
    history -s "${CMDLINE[*]}"
    CMD=${CMDLINE[0]}
    ARGS=("${CMDLINE[@]:1}")
    case "${CMD}" in
        help)
            _help_
            ;;
        env)
            _env_ "${ARGS[@]}"
            ;;
        col)
            _col_ "${ARGS[@]}"
            ;;
        item)
            _item_ "${ARGS[@]}"
            ;;
        run)
            _run_ "${ARGS[@]}"
            ;;
        exit|quit)
            break
            ;;
        "")
            continue
            ;;
        *)
            echo "Unknown command: ${CMD}" >&2
        esac
        unset CMDLINE CMD ARGS
done

history -w "${BASHMAN_HISTORY}"
